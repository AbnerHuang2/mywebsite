<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Skitii</title><link>/</link><description>Recent content on Skitii</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 27 Jul 2022 17:07:07 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Mysql主从同步竟然这么多细节</title><link>/posts/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%AB%9F%E7%84%B6%E8%BF%99%E4%B9%88%E5%A4%9A%E7%BB%86%E8%8A%82/</link><pubDate>Wed, 27 Jul 2022 17:07:07 +0000</pubDate><guid>/posts/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%AB%9F%E7%84%B6%E8%BF%99%E4%B9%88%E5%A4%9A%E7%BB%86%E8%8A%82/</guid><description>整体流程 # 主库发生数据变更，将数据写入到binlog文件中 从库I/O线程发起dump请求 主库I/O线程将指定位点的binlog推送到从库 从库I/O线程写入本地的中转日志（relay log）文件（与binlog文件一致） 从库SQL线程读取relay log文件重放 传输文件格式 # 通过上图可以看见，主库会将binlog推送从库。 那么binlog是什么格式？</description></item><item><title>Spring真的完全解决了循环依赖吗</title><link>/posts/spring%E7%9C%9F%E7%9A%84%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%90%97/</link><pubDate>Mon, 20 Jun 2022 17:51:15 +0000</pubDate><guid>/posts/spring%E7%9C%9F%E7%9A%84%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%90%97/</guid><description>感觉好久没写过博客了，刚好最近遇到一个还挺有意思的问题，就记录一下吧。</description></item><item><title>Redis分布式锁</title><link>/posts/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link><pubDate>Wed, 27 Apr 2022 09:30:31 +0000</pubDate><guid>/posts/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid><description>认识分布式锁 # Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.</description></item><item><title>Jstack分析神器</title><link>/posts/jstack%E5%88%86%E6%9E%90%E7%A5%9E%E5%99%A8/</link><pubDate>Tue, 19 Apr 2022 17:44:18 +0000</pubDate><guid>/posts/jstack%E5%88%86%E6%9E%90%E7%A5%9E%E5%99%A8/</guid><description>What is fastthread.</description></item><item><title>Jstack实践-线程无限增长导致被容器OOMkilled</title><link>/posts/jstack%E5%AE%9E%E8%B7%B5-%E7%BA%BF%E7%A8%8B%E6%97%A0%E9%99%90%E5%A2%9E%E9%95%BF%E5%AF%BC%E8%87%B4%E8%A2%AB%E5%AE%B9%E5%99%A8oomkilled/</link><pubDate>Tue, 19 Apr 2022 16:30:09 +0000</pubDate><guid>/posts/jstack%E5%AE%9E%E8%B7%B5-%E7%BA%BF%E7%A8%8B%E6%97%A0%E9%99%90%E5%A2%9E%E9%95%BF%E5%AF%BC%E8%87%B4%E8%A2%AB%E5%AE%B9%E5%99%A8oomkilled/</guid><description>现象 # 容器每隔一段时候就会自动重启，大概一周左右。理由是OOMkilled。 查看jstack日志，发现里面竟有3319个线程在运行。 分析 # 看看这些线程都在做什么？（图表来源于fastthread.</description></item><item><title>Jstack-抓住摸鱼的线程</title><link>/posts/jstack-%E6%8A%93%E4%BD%8F%E6%91%B8%E9%B1%BC%E7%9A%84%E7%BA%BF%E7%A8%8B/</link><pubDate>Tue, 19 Apr 2022 16:24:35 +0000</pubDate><guid>/posts/jstack-%E6%8A%93%E4%BD%8F%E6%91%B8%E9%B1%BC%E7%9A%84%E7%BA%BF%E7%A8%8B/</guid><description>jstack是啥 # jstack是java虚拟机自带的一种堆栈跟踪工具，用于分析java线程的执行情况 jstack常用实践 # 死锁分析 cpu高负载分析 请求外部资源导致的长时间等待 jstack常用命令 # jstack Options -F 强制dump线程堆栈信息.</description></item><item><title>Java堆外内存排查</title><link>/posts/java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%8E%92%E6%9F%A5/</link><pubDate>Sat, 19 Feb 2022 19:52:32 +0000</pubDate><guid>/posts/java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%8E%92%E6%9F%A5/</guid><description>启动参数 # java -XX:NativeMemoryTracking=detail -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+AlwaysPreTouch -XX:ReservedCodeCacheSize=128m -XX:InitialCodeCacheSize=128m -Xss512k -Xmx1g -Xms1g -XX:+UseG1GC -XX:G1HeapRegionSize=4M -jar lib/helfy-1.</description></item><item><title>Java连接Mysql字符集设置过程详解</title><link>/posts/java%E8%BF%9E%E6%8E%A5mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AE%BE%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link><pubDate>Sun, 13 Feb 2022 11:08:37 +0000</pubDate><guid>/posts/java%E8%BF%9E%E6%8E%A5mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AE%BE%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid><description>现象 # 生产数据库设置了数据库的字符集为utf8mb4。数据库层面可以正常插入表情。但是在java程序中设置表情却不生效。 测试数据库也设置了数据库的字符集为utf8mb4。数据库层面可以正常插入表情。但是在java程序中也可以正常插入表情。 测试和生产环境的区别是：测试环境数据库重启过。生产没有==。 但是生产环境重启数据库影响太大，不太现实。 有没有什么其他的解决方案呢？请往下看。</description></item><item><title>Mysql慢查询分析</title><link>/posts/mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/</link><pubDate>Sat, 12 Feb 2022 09:53:49 +0000</pubDate><guid>/posts/mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/</guid><description>从mybatis日志中获取sql语句，通过explain进行分析。 # grep -E &amp;#39;==&amp;gt; Preparing:&amp;#39; bytello.</description></item><item><title>OrderBy踩坑之路</title><link>/posts/orderby%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF/</link><pubDate>Thu, 10 Feb 2022 20:13:06 +0000</pubDate><guid>/posts/orderby%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF/</guid><description>先看一条社死SQL # SELECT*FROM t_device_online where device_id=8788 orderby start_time **desc limit **1;</description></item><item><title>Mysql插入删除死锁问题排查</title><link>/posts/mysql%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</link><pubDate>Thu, 10 Feb 2022 19:58:16 +0000</pubDate><guid>/posts/mysql%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</guid><description>查看业务日志 # 查看死锁日志 # show engine innodb status; （查询语句）</description></item><item><title>站在使用角度看缓存</title><link>/posts/%E7%AB%99%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%BC%93%E5%AD%98/</link><pubDate>Wed, 09 Feb 2022 19:27:10 +0000</pubDate><guid>/posts/%E7%AB%99%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%BC%93%E5%AD%98/</guid><description>概述 # 缓存是一件很复杂的事情。我认为比较核心的知识应该是，</description></item><item><title>Redis网络事件模型</title><link>/posts/redis%E7%BD%91%E7%BB%9C%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</link><pubDate>Tue, 08 Feb 2022 19:31:59 +0000</pubDate><guid>/posts/redis%E7%BD%91%E7%BB%9C%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</guid><description>Redis的设计中，有一个被大家熟知的概念，就是在6.</description></item></channel></rss>